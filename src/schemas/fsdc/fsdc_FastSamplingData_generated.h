// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_FSDCFASTSAMPLINGDATA_FSD_H_
#define FLATBUFFERS_GENERATED_FSDCFASTSAMPLINGDATA_FSD_H_

#include "flatbuffers/flatbuffers.h"

namespace FSD {

struct uint8;

struct int8;

struct uint16;

struct int16;

struct uint32;

struct int32;

struct uint64;

struct int64;

struct float32;

struct float64;

struct FastSamplingData;

enum type {
  type_NONE = 0,
  type_uint8 = 1,
  type_int8 = 2,
  type_uint16 = 3,
  type_int16 = 4,
  type_uint32 = 5,
  type_int32 = 6,
  type_uint64 = 7,
  type_int64 = 8,
  type_float32 = 9,
  type_float64 = 10,
  type_MIN = type_NONE,
  type_MAX = type_float64
};

inline const char **EnumNamestype() {
  static const char *names[] = {
    "NONE",
    "uint8",
    "int8",
    "uint16",
    "int16",
    "uint32",
    "int32",
    "uint64",
    "int64",
    "float32",
    "float64",
    nullptr
  };
  return names;
}

inline const char *EnumNametype(type e) {
  const size_t index = static_cast<int>(e);
  return EnumNamestype()[index];
}

template<typename T> struct typeTraits {
  static const type enum_value = type_NONE;
};

template<> struct typeTraits<uint8> {
  static const type enum_value = type_uint8;
};

template<> struct typeTraits<int8> {
  static const type enum_value = type_int8;
};

template<> struct typeTraits<uint16> {
  static const type enum_value = type_uint16;
};

template<> struct typeTraits<int16> {
  static const type enum_value = type_int16;
};

template<> struct typeTraits<uint32> {
  static const type enum_value = type_uint32;
};

template<> struct typeTraits<int32> {
  static const type enum_value = type_int32;
};

template<> struct typeTraits<uint64> {
  static const type enum_value = type_uint64;
};

template<> struct typeTraits<int64> {
  static const type enum_value = type_int64;
};

template<> struct typeTraits<float32> {
  static const type enum_value = type_float32;
};

template<> struct typeTraits<float64> {
  static const type enum_value = type_float64;
};

bool Verifytype(flatbuffers::Verifier &verifier, const void *obj, type type);
bool VerifytypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct uint8 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VALUE = 4
  };
  const flatbuffers::Vector<uint8_t> *value() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_VALUE) &&
           verifier.Verify(value()) &&
           verifier.EndTable();
  }
};

struct uint8Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value) {
    fbb_.AddOffset(uint8::VT_VALUE, value);
  }
  uint8Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  uint8Builder &operator=(const uint8Builder &);
  flatbuffers::Offset<uint8> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<uint8>(end);
    return o;
  }
};

inline flatbuffers::Offset<uint8> Createuint8(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value = 0) {
  uint8Builder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline flatbuffers::Offset<uint8> Createuint8Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *value = nullptr) {
  return FSD::Createuint8(
      _fbb,
      value ? _fbb.CreateVector<uint8_t>(*value) : 0);
}

struct int8 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VALUE = 4
  };
  const flatbuffers::Vector<int8_t> *value() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_VALUE) &&
           verifier.Verify(value()) &&
           verifier.EndTable();
  }
};

struct int8Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::Vector<int8_t>> value) {
    fbb_.AddOffset(int8::VT_VALUE, value);
  }
  int8Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  int8Builder &operator=(const int8Builder &);
  flatbuffers::Offset<int8> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<int8>(end);
    return o;
  }
};

inline flatbuffers::Offset<int8> Createint8(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> value = 0) {
  int8Builder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline flatbuffers::Offset<int8> Createint8Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int8_t> *value = nullptr) {
  return FSD::Createint8(
      _fbb,
      value ? _fbb.CreateVector<int8_t>(*value) : 0);
}

struct uint16 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VALUE = 4
  };
  const flatbuffers::Vector<uint16_t> *value() const {
    return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_VALUE) &&
           verifier.Verify(value()) &&
           verifier.EndTable();
  }
};

struct uint16Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> value) {
    fbb_.AddOffset(uint16::VT_VALUE, value);
  }
  uint16Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  uint16Builder &operator=(const uint16Builder &);
  flatbuffers::Offset<uint16> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<uint16>(end);
    return o;
  }
};

inline flatbuffers::Offset<uint16> Createuint16(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint16_t>> value = 0) {
  uint16Builder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline flatbuffers::Offset<uint16> Createuint16Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint16_t> *value = nullptr) {
  return FSD::Createuint16(
      _fbb,
      value ? _fbb.CreateVector<uint16_t>(*value) : 0);
}

struct int16 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VALUE = 4
  };
  const flatbuffers::Vector<int16_t> *value() const {
    return GetPointer<const flatbuffers::Vector<int16_t> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_VALUE) &&
           verifier.Verify(value()) &&
           verifier.EndTable();
  }
};

struct int16Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::Vector<int16_t>> value) {
    fbb_.AddOffset(int16::VT_VALUE, value);
  }
  int16Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  int16Builder &operator=(const int16Builder &);
  flatbuffers::Offset<int16> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<int16>(end);
    return o;
  }
};

inline flatbuffers::Offset<int16> Createint16(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int16_t>> value = 0) {
  int16Builder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline flatbuffers::Offset<int16> Createint16Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int16_t> *value = nullptr) {
  return FSD::Createint16(
      _fbb,
      value ? _fbb.CreateVector<int16_t>(*value) : 0);
}

struct uint32 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VALUE = 4
  };
  const flatbuffers::Vector<uint32_t> *value() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_VALUE) &&
           verifier.Verify(value()) &&
           verifier.EndTable();
  }
};

struct uint32Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> value) {
    fbb_.AddOffset(uint32::VT_VALUE, value);
  }
  uint32Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  uint32Builder &operator=(const uint32Builder &);
  flatbuffers::Offset<uint32> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<uint32>(end);
    return o;
  }
};

inline flatbuffers::Offset<uint32> Createuint32(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> value = 0) {
  uint32Builder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline flatbuffers::Offset<uint32> Createuint32Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint32_t> *value = nullptr) {
  return FSD::Createuint32(
      _fbb,
      value ? _fbb.CreateVector<uint32_t>(*value) : 0);
}

struct int32 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VALUE = 4
  };
  const flatbuffers::Vector<int32_t> *value() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_VALUE) &&
           verifier.Verify(value()) &&
           verifier.EndTable();
  }
};

struct int32Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::Vector<int32_t>> value) {
    fbb_.AddOffset(int32::VT_VALUE, value);
  }
  int32Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  int32Builder &operator=(const int32Builder &);
  flatbuffers::Offset<int32> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<int32>(end);
    return o;
  }
};

inline flatbuffers::Offset<int32> Createint32(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> value = 0) {
  int32Builder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline flatbuffers::Offset<int32> Createint32Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *value = nullptr) {
  return FSD::Createint32(
      _fbb,
      value ? _fbb.CreateVector<int32_t>(*value) : 0);
}

struct uint64 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VALUE = 4
  };
  const flatbuffers::Vector<uint64_t> *value() const {
    return GetPointer<const flatbuffers::Vector<uint64_t> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_VALUE) &&
           verifier.Verify(value()) &&
           verifier.EndTable();
  }
};

struct uint64Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::Vector<uint64_t>> value) {
    fbb_.AddOffset(uint64::VT_VALUE, value);
  }
  uint64Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  uint64Builder &operator=(const uint64Builder &);
  flatbuffers::Offset<uint64> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<uint64>(end);
    return o;
  }
};

inline flatbuffers::Offset<uint64> Createuint64(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint64_t>> value = 0) {
  uint64Builder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline flatbuffers::Offset<uint64> Createuint64Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint64_t> *value = nullptr) {
  return FSD::Createuint64(
      _fbb,
      value ? _fbb.CreateVector<uint64_t>(*value) : 0);
}

struct int64 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VALUE = 4
  };
  const flatbuffers::Vector<int64_t> *value() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_VALUE) &&
           verifier.Verify(value()) &&
           verifier.EndTable();
  }
};

struct int64Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::Vector<int64_t>> value) {
    fbb_.AddOffset(int64::VT_VALUE, value);
  }
  int64Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  int64Builder &operator=(const int64Builder &);
  flatbuffers::Offset<int64> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<int64>(end);
    return o;
  }
};

inline flatbuffers::Offset<int64> Createint64(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> value = 0) {
  int64Builder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline flatbuffers::Offset<int64> Createint64Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *value = nullptr) {
  return FSD::Createint64(
      _fbb,
      value ? _fbb.CreateVector<int64_t>(*value) : 0);
}

struct float32 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VALUE = 4
  };
  const flatbuffers::Vector<float> *value() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_VALUE) &&
           verifier.Verify(value()) &&
           verifier.EndTable();
  }
};

struct float32Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::Vector<float>> value) {
    fbb_.AddOffset(float32::VT_VALUE, value);
  }
  float32Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  float32Builder &operator=(const float32Builder &);
  flatbuffers::Offset<float32> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<float32>(end);
    return o;
  }
};

inline flatbuffers::Offset<float32> Createfloat32(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<float>> value = 0) {
  float32Builder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline flatbuffers::Offset<float32> Createfloat32Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *value = nullptr) {
  return FSD::Createfloat32(
      _fbb,
      value ? _fbb.CreateVector<float>(*value) : 0);
}

struct float64 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VALUE = 4
  };
  const flatbuffers::Vector<double> *value() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_VALUE) &&
           verifier.Verify(value()) &&
           verifier.EndTable();
  }
};

struct float64Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::Vector<double>> value) {
    fbb_.AddOffset(float64::VT_VALUE, value);
  }
  float64Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  float64Builder &operator=(const float64Builder &);
  flatbuffers::Offset<float64> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<float64>(end);
    return o;
  }
};

inline flatbuffers::Offset<float64> Createfloat64(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<double>> value = 0) {
  float64Builder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline flatbuffers::Offset<float64> Createfloat64Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<double> *value = nullptr) {
  return FSD::Createfloat64(
      _fbb,
      value ? _fbb.CreateVector<double>(*value) : 0);
}

struct FastSamplingData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PV = 4,
    VT_TIMESTAMP = 6,
    VT_DIMENSIONS = 8,
    VT_DATA_TYPE = 10,
    VT_DATA = 12
  };
  const flatbuffers::String *pv() const {
    return GetPointer<const flatbuffers::String *>(VT_PV);
  }
  uint64_t timestamp() const {
    return GetField<uint64_t>(VT_TIMESTAMP, 0);
  }
  const flatbuffers::Vector<uint64_t> *dimensions() const {
    return GetPointer<const flatbuffers::Vector<uint64_t> *>(VT_DIMENSIONS);
  }
  type data_type() const {
    return static_cast<type>(GetField<uint8_t>(VT_DATA_TYPE, 0));
  }
  const void *data() const {
    return GetPointer<const void *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_PV) &&
           verifier.Verify(pv()) &&
           VerifyField<uint64_t>(verifier, VT_TIMESTAMP) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DIMENSIONS) &&
           verifier.Verify(dimensions()) &&
           VerifyField<uint8_t>(verifier, VT_DATA_TYPE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DATA) &&
           Verifytype(verifier, data(), data_type()) &&
           verifier.EndTable();
  }
};

struct FastSamplingDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pv(flatbuffers::Offset<flatbuffers::String> pv) {
    fbb_.AddOffset(FastSamplingData::VT_PV, pv);
  }
  void add_timestamp(uint64_t timestamp) {
    fbb_.AddElement<uint64_t>(FastSamplingData::VT_TIMESTAMP, timestamp, 0);
  }
  void add_dimensions(flatbuffers::Offset<flatbuffers::Vector<uint64_t>> dimensions) {
    fbb_.AddOffset(FastSamplingData::VT_DIMENSIONS, dimensions);
  }
  void add_data_type(type data_type) {
    fbb_.AddElement<uint8_t>(FastSamplingData::VT_DATA_TYPE, static_cast<uint8_t>(data_type), 0);
  }
  void add_data(flatbuffers::Offset<void> data) {
    fbb_.AddOffset(FastSamplingData::VT_DATA, data);
  }
  FastSamplingDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FastSamplingDataBuilder &operator=(const FastSamplingDataBuilder &);
  flatbuffers::Offset<FastSamplingData> Finish() {
    const auto end = fbb_.EndTable(start_, 5);
    auto o = flatbuffers::Offset<FastSamplingData>(end);
    return o;
  }
};

inline flatbuffers::Offset<FastSamplingData> CreateFastSamplingData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> pv = 0,
    uint64_t timestamp = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint64_t>> dimensions = 0,
    type data_type = type_NONE,
    flatbuffers::Offset<void> data = 0) {
  FastSamplingDataBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_data(data);
  builder_.add_dimensions(dimensions);
  builder_.add_pv(pv);
  builder_.add_data_type(data_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<FastSamplingData> CreateFastSamplingDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *pv = nullptr,
    uint64_t timestamp = 0,
    const std::vector<uint64_t> *dimensions = nullptr,
    type data_type = type_NONE,
    flatbuffers::Offset<void> data = 0) {
  return FSD::CreateFastSamplingData(
      _fbb,
      pv ? _fbb.CreateString(pv) : 0,
      timestamp,
      dimensions ? _fbb.CreateVector<uint64_t>(*dimensions) : 0,
      data_type,
      data);
}

inline bool Verifytype(flatbuffers::Verifier &verifier, const void *obj, type type) {
  switch (type) {
    case type_NONE: {
      return true;
    }
    case type_uint8: {
      auto ptr = reinterpret_cast<const uint8 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case type_int8: {
      auto ptr = reinterpret_cast<const int8 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case type_uint16: {
      auto ptr = reinterpret_cast<const uint16 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case type_int16: {
      auto ptr = reinterpret_cast<const int16 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case type_uint32: {
      auto ptr = reinterpret_cast<const uint32 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case type_int32: {
      auto ptr = reinterpret_cast<const int32 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case type_uint64: {
      auto ptr = reinterpret_cast<const uint64 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case type_int64: {
      auto ptr = reinterpret_cast<const int64 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case type_float32: {
      auto ptr = reinterpret_cast<const float32 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case type_float64: {
      auto ptr = reinterpret_cast<const float64 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifytypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!Verifytype(
        verifier,  values->Get(i), types->GetEnum<type>(i))) {
      return false;
    }
  }
  return true;
}

inline const FSD::FastSamplingData *GetFastSamplingData(const void *buf) {
  return flatbuffers::GetRoot<FSD::FastSamplingData>(buf);
}

inline const char *FastSamplingDataIdentifier() {
  return "fsdc";
}

inline bool FastSamplingDataBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, FastSamplingDataIdentifier());
}

inline bool VerifyFastSamplingDataBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<FSD::FastSamplingData>(FastSamplingDataIdentifier());
}

inline void FinishFastSamplingDataBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<FSD::FastSamplingData> root) {
  fbb.Finish(root, FastSamplingDataIdentifier());
}

}  // namespace FSD

#endif  // FLATBUFFERS_GENERATED_FSDCFASTSAMPLINGDATA_FSD_H_
